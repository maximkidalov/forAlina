Есть сайт https://www.overleaf.com/

на нем регаешься и создаешь проект, там в проекте слева пишется код, справа выводится pdf файл

МОЙ КОД:

\documentclass[a4paper]{report}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{tempora}
\usepackage{indentfirst}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{booktabs}
\frenchspacing
\usepackage[
   top=20mm,
   bottom=20mm,
   left=30mm,
   right=10mm]{geometry}


\title{

\LARGE{

\begin{center}
    МИНОБРНАУКИ РОССИИ\\
    Федеральное государственное автономное образовательное учреждение высшего образования\\   
    \textbf{«Омский государственный университет им. Ф.М. Достоевского» }\\
\end{center}

\begin{center}
    \linespread{2}
    \textbf{\\ ОТЧЕТ \\ ПО 2 ЛАБОРАТОРНОЙ РАБОТЕ "АЛГОРИТМЫ СЖАТИЯ ГРАФИЧЕСКОЙ ИНФОРМАЦИИ"}
\end{center}

\begin{flushright}
    \linespread{2}
    \textbf{\\Выполнил:}
    \\ студент 2 курса ФЦТК, МПБ-101-О-01 \\ Санников Илья Дмитриевич

    \textbf{\\Проверил:}
    \\ инженер и старший преподаватель \\ Лейхтер Сергей Владимирович
\end{flushright}

\begin{center}
    \vspace*{\fill}
     Омск 2023г    
\end{center}

\author{}
\date{}

}}

\begin{document}

\maketitle
\newpage

\setlength{\parindent}{1.25cm}
\linespread{1.5}

\LARGE{

\setcounter{page}{2}
\tableofcontents


\newpage
\chapter{Изучение материалов}

Перед началом работы изучил все предоставленные преподавателем материалы, а также материалы данные в интернет-ресурсах. Из первого я узнал об основных этапах сжатия изображения методом JPEG, формулы необходимые на каждом этапе работы:

\begin{center}

    \begin{equation}
    DCT_{ij} = \frac{1}{\sqrt{N}},\ i = 0,         
    \end{equation}

    \begin{equation}
    DCT_{ij} = \sqrt{\frac{2}{N}} \cos{\left(\frac{(2j+1)i\pi}{2N}\right)},\ i > 0,         
    \end{equation}
     
    где $N = 8,\  0 \leq i \leq 7,\ 0 \leq j \leq 7$.
\end{center}

С помощью формулы (1.1) и (1.2) можно посчитать матрицу косинусного транспонирования, необходимую для расчета дальнейших матриц.

\begin{equation}
    RES = DCT * IMG * DCT^T
\end{equation}

Формула (1.3) поможет определить частотное представление изображения из исходного.

\begin{equation}
    Q_{ij} = 1+((1+i+j)q), при\ 0 \leq i \leq 7
\end{equation}

Формула (1.4) является матрицей квантования с помощью которой можно установить элемент сжатия q, чем больше его значение, тем больше будет сжато изображение.

\begin{equation}
    A_{ij} = \frac{RES_{ij}}{Q_{ij}} 
\end{equation}

Матрица посчитаная по формуле (1.5) и является итоговым сжатым изображением, которое после процесса кодировки, по алгоритму Хаффмана, записывается в формате JPEG.

\begin{equation}
    IMG = DCT^T * RES * DCT
\end{equation}

Формула же (1.6) является обратным процессом, получения итогового изображения из сжатого.\\

Из интернет-источника познакомился с формулами преобразования RGB каналов в компоненты YCbCr, из которых использовал формулу преобразования цвета в канал яркости:

\begin{equation}
    Y' = 0.299R' + 0.587G' + 0.114B'
\end{equation}

\newpage
\chapter{Преобразование RGB в YCbCr}

Для лабораторной работы было необходимо выбрать изображение для сжатия. Оно получилось размером 16х16 пикселей (в сумме 256 пикселей), и выглядит следующим образом:\\

\begin{figure}[!h]
    \centering
    \fbox{\includegraphics[width=50mm]{among.eps}}
    \caption{Исходное изображение}
\end{figure}

Для начала было необходимо преобразовать изображение из пространства RGB в YCbCr. Всего существует 3 компоненты, это Y' — компонента яркости, CB и CR являются синей и красной цветоразностными компонентами. Из этих трех выбрал яркость, и приступил к работе.

Для начала необходимо построить матрицу, состоящую только из пикселей яркости изображения. Для ее построения воспользуемся формулой из рис.6, а также программой Adobe Photoshop 2021, в которой предоставляется возможность увидеть RGB цвета каждого отдельного пикселя.

Итоговый результат записал в таблицу в программе Excel, и получил матрицу, состоящую из значений яркости, отделенной от цвета изображения. Матрица имела следующий вид:\\

\[
  IMG =
  \left[ {\begin{array}{cccc}
    133&    168&    \cdots& 112\\
    146&    175&    \cdots& 123\\ 
    \vdots& \vdots& \ddots& \vdots\\
    133&    168&    \cdots& 112\\ 
  \end{array} }\right]
\]



\newpage
\chapter{Частотное представление изображения}

После преобразования необходимо найти ДКП матрицу, по формулам (1.1) и (1.2). Для начала, разбиваем исходное изображение блоки размером 8 на 8 пикселей, и для каждого из них считаем одну ДКП матрицу, для формулы взял значение N = 8, т.к. 1 такой блок имеет именно такой размер, значение i,j указаны по краям матрицы.\\

\[
  DCT =
  \left[ {\begin{array}{cccc}
    0.353535&    0.353535&    \cdots& 0.353535\\
    0.490393&    0.415735&    \cdots& -0.49039\\ 
    \vdots& \vdots& \ddots& \vdots\\
    0.097545&    -0.27779&    \cdots& -0.09755\\ 
  \end{array} }\right]
\]

\[
  DCT^T =
  \left[ {\begin{array}{cccc}
    0.353535&    0.490393&    \cdots& 0.097545\\
    0.353535&    0.415735&    \cdots& -0.27779\\ 
    \vdots& \vdots& \ddots& \vdots\\
    0.353535&    -0.49039&    \cdots& -0.09755\\ 
  \end{array} }\right]
\]

После вычисления ДКП приступил к расчету самой матрицы част. представ. изображения для этого воспользовался формулой (1.3). Для вычисления по этой формуле необходимо было также рассчитать транспонированную матрицу ДКП. После вычисления всех необходимых данных приступил к вычислению и в итоге получил матрицу изображения.\\



\[
  RES =
  \left[ {\begin{array}{cccc}
    1254.25&    4.38093&    \cdots& -62.017\\
    195.692&    -65.377&    \cdots& 64.4077\\ 
    \vdots& \vdots& \ddots& \vdots\\
    -2.8744&    28.3972&    \cdots& 12.325\\ 
  \end{array} }\right]
\]


\newpage
\chapter{Матрица квантования}

Следующим этапом необходимо было вычислить матрицу квантования, для этого воспользовался формулой (1.4). Решил проверить сжатие изображение при небольшом коэффициенте сжатия, а именно q = 2.\\

\[
  Q =
  \left[ {\begin{array}{ccccc}
    3&    5&    \cdots& 17 \\
    5&    7&    \cdots& 19 \\ 
    \vdots& \vdots& \ddots& \vdots\\
    17&    19&    \cdots& 31\\ 
  \end{array} }\right]
\]

Такая матрица позволит ужать изображение приблезительно в 2 раза, что несильно повлияет на качество изображения, но позволит сильно уменьшить занимаемое им количество памяти.

\newpage
\chapter{Итог сжатия изображения}

Для получения итогового сжатого изображения воспользовался формулой (1.5). И в итоге получил матрицу размером как исходное изображение, которое можно будет закодировать в будущем.

\[
  A =
  \left[ {\begin{array}{ccccc}
    418&    0&    \cdots& -3 \\
    39&    -7&    \cdots& 3 \\ 
    \vdots& \vdots& \ddots& \vdots\\
    0&    1&    \cdots& 0\\ 
  \end{array} }\right]
\]

\newpage
\chapter{Преобразование в вектор и кодирование}

Для того чтобы можно было хранить данную информацию в компьютере матрицу с сжатым изображением преобразуют в вектор по принципу «зигзаг», т.е. по диагонали, таким образом получается собрать как можно больше повторов поблизости.  Итоговый внешний вид вектора, сжатого изображения выглядит следующим образом:

$$\vec{IMG} = <418,\ 0,\ 39,\ 6,\ -7,\ ...\ ,\ 0,\ 0,\ 0>$$

После того как записали матрицу в виде вектора, необходимо сократить количество повторов значений в нем. Для этого воспользуемся алгоритмом RLE. И получим итоговый результат в виде вектора, состоящего из элементов [значение; количество повторов]:

$$ \vec{IMG} = <[418;1],[0;1],[39;1],[6;1],[-7;1], ... ,[0;5],[1;2],[0;10]>$$

Далее уже строится дерево по алгоритму Хаффмана, в котором наиболее часто попадающийся элемент имеет самую короткую длинну кода, а также самый часто попадающийся элемент самую длинную. Для начала считаем количество каждого элемента в векторе, для визуализации покажу результат в таблице:\\

\begin{table}[ht]
    \centering
    \resizebox{\textwidth}{!}{
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
        \hline 
        0 & 1 & -1 & -2 & 2 & -3 & ... & 418 \\ \hline 
        75 & 25 & 20 & 19 & 16 & 13 & ... & 1 \\ 
        \hline
    \end{tabular}}
    \caption{Количество одинаковых элементов в векторе}
    \label{tab:my_label}
\end{table}

После подсчета количества повторов всех элементов полученного вектора, строится дерево, с помощью которого и происходит процесс кодировки дерева.\\

\begin{figure}[!h]
    \centering
    \fbox{\includegraphics[width=100mm]{Haffman.eps}}
    \caption{Дерево по лагоритму Хаффмана}
\end{figure}

\newpage
\begin{thebibliography}{}
    \addcontentsline{toc}{chapter}{Литература}
    \bibitem{https://ru.wikipedia.org/wiki/YCbCr}  Wikipedia  -  "YCbCr"; URL: https://ru.wikipedia.org/wiki/YCbCr (дата обращения: 02.03.2023)
\end{thebibliography}

\end{document}
